diff --git a/node_modules/@types/jest/index.d.ts b/node_modules/@types/jest/index.d.ts
index 098290f..3fe7d75 100755
--- a/node_modules/@types/jest/index.d.ts
+++ b/node_modules/@types/jest/index.d.ts
@@ -137,7 +137,7 @@ declare namespace jest {
      * Use the automatic mocking system to generate a mocked version of the given module.
      */
     // tslint:disable-next-line: no-unnecessary-generics
-    function createMockFromModule<T>(moduleName: string): T;
+    function createMockFromModule(moduleName: string): unknown;
     /**
      * Resets the state of all mocks.
      * Equivalent to calling .mockReset() on every mocked function.
@@ -156,7 +156,7 @@ declare namespace jest {
      * been scheduled, they will be cleared and will never have the opportunity
      * to execute in the future.
      */
-    function clearAllTimers(): typeof jest;
+    function clearAllTimers(): void;
     /**
      * Returns the number of fake timers still left to run.
      */
@@ -217,7 +217,7 @@ declare namespace jest {
      * Use the automatic mocking system to generate a mocked version of the given module.
      */
     // tslint:disable-next-line: no-unnecessary-generics
-    function genMockFromModule<T>(moduleName: string): T;
+    function genMockFromModule(moduleName: string): unknown;
     /**
      * Returns whether the given function is a mock function.
      */
@@ -236,7 +236,7 @@ declare namespace jest {
      *
      * Note: while it needs to be a function so that input type is changed, the helper itself does nothing else than returning the given input value.
      */
-    function mocked<T>(item: T, deep?: false): MaybeMocked<T>;
+    function mocked<T>(item: T, deep: { shallow: true }): MaybeMocked<T>;
     /**
      * The mocked test helper provides typings on your mocked modules and even
      * their deep methods, based on the typing of its source. It makes use of
@@ -245,19 +245,19 @@ declare namespace jest {
      *
      * Note: while it needs to be a function so that input type is changed, the helper itself does nothing else than returning the given input value.
      */
-    function mocked<T>(item: T, deep: true): MaybeMockedDeep<T>;
+    function mocked<T>(item: T, deep?: { shallow: false }): MaybeMockedDeep<T>;
     /**
      * Returns the actual module instead of a mock, bypassing all checks on
      * whether the module should receive a mock implementation or not.
      */
     // tslint:disable-next-line: no-unnecessary-generics
-    function requireActual<TModule extends {} = any>(moduleName: string): TModule;
+    function requireActual(moduleName: string): unknown;
     /**
      * Returns a mock module instead of the actual module, bypassing all checks
      * on whether the module should be required normally or not.
      */
     // tslint:disable-next-line: no-unnecessary-generics
-    function requireMock<TModule extends {} = any>(moduleName: string): TModule;
+    function requireMock(moduleName: string): unknown;
     /**
      * Resets the module registry - the cache of all required modules. This is
      * useful to isolate modules where local state might conflict between tests.
@@ -278,30 +278,30 @@ declare namespace jest {
      * > Note: This function is only available when using modern fake timers
      * > implementation
      */
-    function runAllImmediates(): typeof jest;
+    function runAllImmediates(): void;
     /**
      * Exhausts the micro-task queue (usually interfaced in node via process.nextTick).
      */
-    function runAllTicks(): typeof jest;
+    function runAllTicks(): void;
     /**
      * Exhausts both the macro-task queue (i.e., all tasks queued by setTimeout(),
      * setInterval(), and setImmediate()) and the micro-task queue (usually interfaced
      * in node via process.nextTick).
      */
-    function runAllTimers(): typeof jest;
+    function runAllTimers(): void;
     /**
      * Executes only the macro-tasks that are currently pending (i.e., only the
      * tasks that have been queued by setTimeout() or setInterval() up to this point).
      * If any of the currently pending macro-tasks schedule new macro-tasks,
      * those new tasks will not be executed by this call.
      */
-    function runOnlyPendingTimers(): typeof jest;
+    function runOnlyPendingTimers(): void;
     /**
      * Advances all timers by msToRun milliseconds. All pending "macro-tasks" that have been
      * queued via setTimeout() or setInterval(), and would be executed within this timeframe
      * will be executed.
      */
-    function advanceTimersByTime(msToRun: number): typeof jest;
+    function advanceTimersByTime(msToRun: number): void;
     /**
      * Advances all timers by the needed milliseconds so that only the next
      * timeouts/intervals will run. Optionally, you can provide steps, so it
@@ -1379,7 +1379,7 @@ declare namespace jest {
     type MockResult<T> = MockResultReturn<T> | MockResultThrow | MockResultIncomplete;
 
     interface MockContext<T, Y extends any[]> {
-        lastCall: Y;
+        lastCall?: Y;
         calls: Y[];
         instances: T[];
         invocationCallOrder: number[];

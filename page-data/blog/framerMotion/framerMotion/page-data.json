{
    "componentChunkName": "component---src-templates-doc-page-layout-tsx",
    "path": "/blog/framerMotion/framerMotion/",
    "result": {"data":{"page":{"id":"92e5d7ac-b4e4-5bee-9294-c243bca9f628","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Framer motion i Jøkul\",\n  \"description\": \"Hvordan lage virkningsfulle bevelgelser på en enkel måte med Jøkul og Framer motion\",\n  \"author\": \"Leiv Fredrik Berge\",\n  \"publishDate\": \"2020.06.06\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Bevegelse er et av hovedprinsippene bak profilen til Fremtind. Men animasjon er ikke lett. Frem til n\\xE5 har vi stort sett basert oss p\\xE5 enkle transformasjoner i ren CSS.\\nN\\xE5r man skal gj\\xF8re mer animasjon, p\\xE5 st\\xF8rre deler av applikasjonen blir det litt kronglete \\xE5 gj\\xF8re alt for h\\xE5nd i CSS. Det finnes utallige javascript bibliotek for \\xE5 forbedre utvikleropplevelsen rundt animasjon.\\nEn av de nyere alternativene er \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.framer.com/motion/\"\n  }, \"Framer Motion\"), \". Det er arvtageren til Pose fra Popmotion, en av de mest popul\\xE6re og likte animasjonsbibilotekene der ute. De fleste animasjonsbibilotekene har en tendens til\\n\\xE5 bli veldig imperative, s\\xE5 det parrer ikke s\\xE5 pent med \\xF8vrig React kode. Framer Motion derimot er f\\xF8rst og fremst deklarativt, selvom du har muligheten til \\xE5 v\\xE6re imperativ om du m\\xE5.\"), mdx(FramerMotionExample, {\n    mdxType: \"FramerMotionExample\"\n  }), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"<motion.div whileHover={{ scale: 1.15 }} whileTap={{ rotate: 45, scale: 0.95 }} />\\n\")), mdx(\"p\", null, \"APIet til Framer Motion er relativt enkelt \\xE5 sette seg inn i, og gir mange mulighter til \\xE5 lage interaktive animasjoner. I eksemplet over er det enkle bevelgelser p\\xE5 hover og tap.\\nDisse blir oversatt til inline style, og s\\xE5 langt det er mulig blir det performant, gpu akselererte, 60 fps css transisjoner. Bibliotektet baserer seg p\\xE5 noen f\\xE5 kompontenter og noen utility hooks.\\nStort sett s\\xE5 kan du gj\\xF8re det meste du trenger av enkle animasjoner med \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"motion.{htmlElement}\"), \", og \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AnimatePresence\"), \". AnimatePresence gir muligheten til \\xE5 lage exit animasjoner, noe som alltid har v\\xE6rt en\\nutfordring i HTML.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"<AnimatePresence>\\n    {isOpen &&\\n        filteredItems.map((item) => (\\n            <motion.li\\n                key={item.title}\\n                initial={{ y: -60, opacity: 0 }}\\n                animate={{ y: 0, x: 0, opacity: 1, transition: { duration: 0.25, delay: 0.2 } }}\\n                exit={{ x: 10, opacity: 0, transition: { duration: 0.25 } }}\\n                className=\\\"jkl-portal-full-screen-menu-item\\\"\\n            >\\n                <FullScreenMenuItem path={item.path} title={item.title} />\\n            </motion.li>\\n        ))}\\n</AnimatePresence>\\n\")), mdx(\"p\", null, \"Dette er animasjonen til hovedmenyen her i portalen. Initial er ikke overaskende startverdien til animasjonen. Denne kan v\\xE6re false, om du ikke vil at f\\xF8rste render skal animere noe.\\nAnimate blir overgangen fra intital staten, til elementet er klart. Her er det ogs\\xE5 spesifisert noe rundt hvor lenge animasjonen skal vare og et lite delay. Exit spesifiserer hvordan\\nanimasjonen ut av DOMet skal v\\xE6re. Noen viktige punkter med dette er at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"motion\"), \" m\\xE5 v\\xE6re f\\xF8rste child av \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AnimatePresence\"), \", dette kravet kommer nok til \\xE5 forsvinne etterhvert, men\\ns\\xE5nn React virker per 16.12.0 m\\xE5 AnimatePresence og motion f\\xF8lge etter hverandre. Det er ogs\\xE5 viktig med unik key, ikke index, for at Framer Motion skal holde kontroll p\\xE5 elementene.\"), mdx(\"p\", null, \"Noen ganger s\\xE5 m\\xE5 du programatisk sette igang animasjonen, da m\\xE5 du til med litt imperativitet, men vi kan pakke det inn p\\xE5 en m\\xE5te som fortsatt gir mening i React-verden. I sidemenyen \\xF8nsker vi\\n\\xE5 animere innholdet i menyen ut med det gamle og inn med de nye n\\xE5r du bytter fra feks \\\"Kompontenter\\\" til \\\"Kom i gang\\\".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const controls = useAnimation();\\n\\nuseEffect(() => {\\n    (async () => {\\n        await controls.start({ x: 0, opacity: 0, transition: { duration: 0.1 } });\\n        await controls.start({ x: -200, opacity: 0, transition: { duration: 0.2 } });\\n        await controls.start({ x: 0, opacity: 1, transition: { duration: 0.2 } });\\n    })();\\n}, [currentSection, controls]);\\n\\nreturn (\\n    <motion.ul animate={controls} className=\\\"jkl-portal-sidebar-menu__items\\\">\\n        <Menu items={items} />\\n    </motion.ul>\\n);\\n\")), mdx(\"p\", null, \"S\\xE5 n\\xE5r \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"currentSection\"), \" endrer seg, s\\xE5 sparker vi igang en async funksjon som starter animasjonssekvensen med objektet vi f\\xE5r tilbake fra useAnimation hooken.\\nVi kobler den til riktig motion element med \\xE5 sende inn objektet i animate propen. Det gj\\xF8r at man kan ganske enkelt orkistrere kompliserte animasjoner.\"), mdx(\"p\", null, \"S\\xE5 langt jeg holdt p\\xE5 med Framer Motion virker det til \\xE5 v\\xE6re en lovende l\\xF8sning for \\xE5 f\\xE5 p\\xE5 plass bevegelsen som Fremtind profilen trenger. Det er fortsatt mye igjen \\xE5 sette seg inn i,\\nfor \\xE5 se om dette kan v\\xE6re en god l\\xF8sning for flere av applikasjonene v\\xE5re, og om vi skal kunne tilby standardiserte varianter igjenom J\\xF8kul feks. God dokumentasjon, god utvikleropplevelse\\nog bra resultat, gj\\xF8r at jeg syns det er verdt \\xE5 jobbe videre med Framer Motion.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Framer motion i Jøkul","react":null,"scss":null,"order":null,"author":"Leiv Fredrik Berge","publishDate":"2020.06.06","group":null}}},"pageContext":{"id":"92e5d7ac-b4e4-5bee-9294-c243bca9f628","title":"Framer motion i Jøkul"}},
    "staticQueryHashes": ["1583095916","1756004727","2550854682","3000541721"]}